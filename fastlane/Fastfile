# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:mac)
xcode_file = "../.xcode_version"
xcversion(version: File.read(xcode_file)) if File.exists?(xcode_file)

platform :mac do
  desc "Run linting"
  lane :lint do
    swiftlint(
      mode: :lint,
      strict: true,
      config_file: '.swiftlint.yml',
      reporter: "codeclimate",
      ignore_exit_status: true,
      output_file: "fastlane/codequality_report.json"
    )
  end

  desc "Register Device"
  lane :register_local_device do
    register_device(
      name: `hostname | cut -d'.' -f1`,
      udid: `ioreg -ad2 -c IOPlatformExpertDevice | xmllint --xpath '//key[.="IOPlatformUUID"]/following-sibling::*[1]/text()' -`,
      team_id: ENV["TEAM_ID"],
      username: ENV["CERT_USERNAME"]
    )
  end

  private_lane :check_certs do |params|
    # Parameters at https://docs.fastlane.tools/actions/cert/
    get_certificates(
      development: params[:cert_development],
      force: false,
      type: params[:cert_type],
      # Don't set the filename so we can easily see which certificate is used
      # Proper one should be 697853WUNU for Fabien penso
      # You can see its value at https://developer.apple.com/account/resources/certificates/list inside the certificate url
      # filename: "developer_id.cer",
      output_path: "./certs",
      username: ENV["CERT_USERNAME"],
      team_id: ENV["TEAM_ID"],
      team_name: ENV["TEAM_NAME"],
      platform: "macos"
    )

    # Parameters at https://docs.fastlane.tools/actions/sigh/
    get_provisioning_profile(
      development: params[:profile_development],
      developer_id: params[:profile_developer_id],
      username: ENV["CERT_USERNAME"],
      app_identifier: ENV["TEAM_IDENTIFIER"],
      team_id: ENV["TEAM_ID"],
      team_name: ENV["TEAM_NAME"],
      provisioning_name: params[:profile_provision_name],
      cert_id: params[:profile_cert_id],
      cert_owner_name: ENV["CERT_OWNER_NAME"],
      skip_certificate_verification: true,
      platform: "macos",
      output_path: "./certs",
      # Actually should be .profileprovision but fastlane complains. It will
      # automatically fetch this profile, but you can just get the one from
      # working md5sum: 5c00f51fe03c198182f31980df51a219
      filename: params[:profile_filename],
      readonly: true, # Don't want to mess up mine
      # force: false,
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Beam.xcodeproj",
      team_id: ENV["TEAM_ID"],
      code_sign_identity: params[:code_sign_identity],
      profile_name: params[:profile_name],
      bundle_identifier: ENV["TEAM_IDENTIFIER"],
      targets: ["Beam"],
      build_configurations: params[:build_configurations])
  end

  desc "Run tests"
  lane :tests do
    update_app_identifier(
      xcodeproj: "Beam.xcodeproj",
      plist_path: "Beam/Configuration/Info.plist",
      app_identifier: ENV["APP_IDENTIFIER"]
    )
    check_certs(profile_development: true,
                cert_development: true,
                profile_provision_name: "Beam Development",
                profile_cert_id: "697853WUNU",
                profile_filename: "development.co.beamapp.macos.mobileprovision",
                code_sign_identity: "Mac Developer",
                profile_name: "Beam Development",
                build_configurations: ["Test"])
    run_tests(
      scheme: "Beam",
      skip_testing: "BeamUITests",
      output_types: "junit",
      output_files: "tests.xml",
      use_system_scm: true,
      number_of_retries: 2
    )
    # For Gitlab artifacts
    slather(
      cobertura_xml: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
    # For automatic code coverage check
    slather(
      simple_output: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
  end

  desc "Run UI tests"
  lane :uitests do
    update_app_identifier(
      xcodeproj: "Beam.xcodeproj",
      plist_path: "Beam/Configuration/Info.plist",
      app_identifier: ENV["APP_IDENTIFIER"]
    )
    check_certs(profile_development: true,
                cert_development: true,
                profile_provision_name: "Beam Development",
                profile_cert_id: "697853WUNU",
                profile_filename: "development.co.beamapp.macos.mobileprovision",
                code_sign_identity: "Mac Developer",
                profile_name: "Beam Development",
                build_configurations: ["Test"])
    run_tests(
      scheme: "Beam",
      only_testing: "BeamUITests",
      output_types: "junit",
      output_files: "tests.xml",
      result_bundle: true,
      use_system_scm: true,
      number_of_retries: 2
    )
    # For Gitlab artifacts
    slather(
      cobertura_xml: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
    # For automatic code coverage check
    slather(
      simple_output: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
  end

  ## To release developer version
  lane :dev do
    check_certs(profile_development: true)

    git_branch

    UI.message "Branch is #{Actions.git_branch}"
    unless ["HEAD", "master", "develop", "release"].include?(Actions.git_branch)
      add_badge(dark: true,
                grayscale: true,
                glob: "/Beam/Assets/Assets.xcassets/AppIcon.appiconset/*.png")
    end

    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: "Beam",
      silent: true,
      clean: true,
      output_directory: "builds",
      output_name: "Beam",
      include_symbols: true,
      # xcargs: settings_to_override,
      # Doesn't work :(
      export_xcargs: 'OTHER_CODE_SIGN_FLAGS="--timestamp"',
      export_method: "development", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id
      export_options: "./ExportOptions.plist",
      # Found this at https://github.com/fastlane/fastlane/issues/15963 or we have archive failed
      skip_package_pkg: true,
      use_system_scm: true
    )
  end

  ## To release DeveloperId signed builds
  lane :beta do
    git_branch
    # Let's do version increment manually in Xcode
    # increment_version_number(bump_type: "patch")
    # Sadly we can't use anything out of a number for building number, so we
    # can't include the current branch. The following fails:
    # build_number = "#{Actions.git_branch}/#{ENV['CI_JOB_ID']}".gsub(/\//, "-")

    build_number = ENV['CI_JOB_ID']
    increment_build_number(build_number: build_number)
    appcast_url = "https://s3.eu-west-3.amazonaws.com/downloads.dev.beamapp.co/#{Actions.git_branch}/AppFeed.json"
    info_plist = "Beam/Configuration/Info.plist"

    UI.message "Set appcast url to #{appcast_url} in #{info_plist}"

    sparkle_set_url(info_plist: info_plist,
                    appcast_url: appcast_url)

    update_app_identifier(
      xcodeproj: "Beam.xcodeproj",
      plist_path: "Beam/Configuration/Info.plist",
      app_identifier: ENV["APP_IDENTIFIER"]
    )

    check_certs(cert_development: false,
                cert_type: "developer_id_application",
                profile_filename: "developer_id.co.beamapp.macos.mobileprovision",
                profile_developer_id: true,
                profile_provision_name: ENV["PROVISION_NAME"],
                profile_cert_id: ENV["CERT_ID"],
                code_sign_identity: "Developer ID Application",
                profile_name: ENV["PROVISION_NAME"],
                build_configurations: ["Release"])

    UI.message "Branch is #{Actions.git_branch}"
    unless ["HEAD", "master", "develop", "release"].include?(Actions.git_branch)
      add_badge(dark: true,
                grayscale: true,
                glob: "/Beam/Assets/Assets.xcassets/AppIcon.appiconset/*.png")
    end

    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: ENV["SCHEME"],
      silent: true,
      clean: true,
      output_directory: "builds",
      output_name: "Beam",
      include_symbols: false,
      # xcargs: settings_to_override,
      # Doesn't work :(
      export_xcargs: 'OTHER_CODE_SIGN_FLAGS="--timestamp"',

      export_method: "developer-id", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id

      ## Doesn't work but it should :(
      #      export_options: {
      #        method: "development",
      #        provisioningProfiles: {
      #          "co.beamapp.macos" => "Beam"
      #        }
      #      }
      ## But this works
      export_options: "./ExportOptionsDeveloperId.plist",
      # Found this at https://github.com/fastlane/fastlane/issues/15963 or we have archive failed
      skip_package_pkg: true

      # export_xcargs: "-allowProvisioningUpdates"
    )
  end

  lane :notarize_build do
    # https://blog.zeplin.io/dev-journal-automate-notarizing-macos-apps-94b0b144ba9d
    notarize(
      package: "builds/Beam.app",
      verbose: true,
      print_log: true,
      bundle_id: ENV["APP_IDENTIFIER"]
    )
  end

  lane :deploy do
    upload_s3
    ping_slack
  end

  lane :ping_sentry do
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")

    sentry_upload_dif(
      org_slug: "beamapp",
      project_slug: "beam-macos",
      # Takes too long
      # force_foreground: true,
      # wait: true,
      path: "builds/Beam.app.dSYM.zip"
    )

    sentry_create_release(
      org_slug: "beamapp",
      project_slug: "beam-macos",
      version: "#{lane_context[SharedValues::VERSION_NUMBER]}+#{lane_context[SharedValues::BUILD_NUMBER]}",
      app_identifier: ENV["TEAM_IDENTIFIER"],
      finalize: true
    )

    sentry_set_commits(
      version: "#{lane_context[SharedValues::VERSION_NUMBER]}+#{lane_context[SharedValues::BUILD_NUMBER]}",
      app_identifier: ENV["TEAM_IDENTIFIER"],
      auto: true, # enable completely automated commit management
      clear: false, # clear all current commits from the release
      # commit: '...', # commit spec, see `sentry-cli releases help set-commits` for more information
    )
  end

  private_lane :create_release_notes do |params|
    # Fetch commit from S3 if we already had one
    download_previous_file(filename: "commit", branch: params[:branch])

    changelog = if File.exists?("../builds/commit")
                  last_commit = File.read("../builds/commit").chomp
                  UI.message "Previous commit file exists, using `git log HEAD...#{last_commit}`"
                  `git log HEAD...#{last_commit}`
                else
                  UI.message "No previous commit file, using `git log -1`"
                  `git log -1`
                end

    File.open("../builds/release_notes.html", "wb") do |f|
      f.write("<html><body><pre>#{changelog}</pre></body></html>")
    end
    
    File.open("../builds/release_notes.md", "wb") do |f|
      f.write("#{changelog}")
    end

    # Store this commit
    File.open("../builds/commit", "wb") do |f|
      current_commit = `git rev-parse HEAD`.chomp
      UI.message "Storing current commit #{current_commit} for next release notes"
      f.write(current_commit)
    end
  end

  lane :upload_s3 do |params|
    # We want the build number from `builds/Beam.app/Contents/Info.plist`
    # get_version_number
    # get_build_number
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    git_branch

    create_release_notes(branch: params[:branch] || Actions.git_branch)

    upload_update_feed(branch: params[:branch] || Actions.git_branch)
    s3_path = s3_path_from_branch(params[:branch] || Actions.git_branch)

    # This should be last upload, or Slack links will be wrong
    aws_s3(
      access_key: ENV["AWS_ACCESS_KEY_ID"],
      secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"],
      bucket: ENV["S3_BUCKET"],
      region: ENV["AWS_DEFAULT_REGION"],
      upload_metadata: true,
      files: [
        "builds/Beam.dmg",
        "builds/Beam.zip",
        "builds/Beam.app.dSYM.zip",
        "builds/release_notes.html"
      ],
      # Doesn't work the way I expected
      # endpoint: "http://downloads.dev.beamapp.co",
      path: s3_path
    )

    lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].each do |file|
      UI.success "S3: #{file}"
    end
  end

  lane :publish_release do
    upload_s3(branch: "release")
    ping_slack
  end

  private_lane :upload_update_feed do |params|
    # I have to do Sparkle at the same time, as `increment_build_number`
    # modifies Beam/Configuration/Info.plist but this file is not propagated to
    # other CI jobs

    generate_update_feed(branch: params[:branch])

    s3_path = params[:branch]

    aws_s3(
      access_key: ENV["AWS_ACCESS_KEY_ID"],
      secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"],
      bucket: ENV["S3_BUCKET"],
      region: ENV["AWS_DEFAULT_REGION"],
      upload_metadata: true,
      files: [
        "builds/AppFeed.json",
        "builds/commit"
      ],
      # Doesn't work the way I expected
      # endpoint: "http://downloads.dev.beamapp.co",
      path: s3_path
    )

    lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].each do |file|
      UI.success "S3: #{file}"
    end
  end

  def s3_path_from_branch(branch)
    git_branch
    branch ||= Actions.git_branch
    result = if ["master", "develop", "release"].include?(branch)
      "#{branch}/#{lane_context[SharedValues::VERSION_NUMBER]}/#{lane_context[SharedValues::BUILD_NUMBER]}"
    else
      branch
    end

    UI.success "s3_path_from_branch: #{result}"

    result
  end

  private_lane :download_previous_file do |params|
    filename = params[:filename]
    default_file = params[:default_file]
    s3_path = params[:branch]

    s3_client = Aws::S3::Client.new(region: ENV["AWS_DEFAULT_REGION"],
                                   access_key_id: ENV["AWS_ACCESS_KEY_ID"],
                                   secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"])

    s3_client.get_object(
      response_target: "../builds/#{filename}",
      bucket: ENV["S3_BUCKET"],
      key: "#{s3_path}/#{filename}"
    )
    UI.success "S3: Fetched https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}/#{filename}"
  rescue Aws::S3::Errors::NoSuchKey => e
    UI.message "S3: https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}/#{filename} does not exist"
    if default_file
      FileUtils.cp(default_file, "../builds/#{filename}")
    end
  rescue
    UI.error "S3: Error fetching #{s3_path}/#{filename}: #{$!}"
    raise $!
  end

  private_lane :generate_update_feed do |params|
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    s3_path = s3_path_from_branch(params[:branch])

    directory = "https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}"
    app_download_url = "#{directory}/Beam.zip"
    update_json_url = "#{directory}/AppFeed.json"
    release_notes_html_url = "#{directory}/release_notes.html"
    human_version = "#{lane_context[SharedValues::VERSION_NUMBER]}"
    machine_version = "#{lane_context[SharedValues::BUILD_NUMBER]}"
    release_title = "Version #{human_version}, build #{machine_version}"
        
    rootFolder = Dir.chdir("..") { Dir.pwd } 
    UI.success "#{rootFolder}"
    
    appFeedBuilder = "../Extern/AutoUpdate/AppFeedBuilder"

    build = "cd #{appFeedBuilder} && swift build"
    
    UI.success "#{build}"
    outputBuild = Actions.sh(build)
    UI.success "#{outputBuild}"
      
    run = ["cd #{appFeedBuilder} &&",
      "swift run AppFeedBuilder", update_json_url, "'#{release_title}'", human_version, machine_version, app_download_url, 
      "--output-path", "#{rootFolder}/builds", 
      "--release-notes-url", release_notes_html_url].join(' ')
    
    UI.success "#{run}"
    output = Actions.sh(run)
    UI.success "#{output}"

    UI.success "AutoUpdate: Successfully added a release item to the AppFeed JSON file"
    UI.success "AutoUpdate: Added #{human_version} #{machine_version} at #{app_download_url}"
  end

  private_lane :ping_slack do
    git_branch

    next unless ["HEAD", "master", "develop", "release"].include?(Actions.git_branch)

    attachments = lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].map do |file|
      {
        title_link: file,
        fallback: file
      }
    end

    slack(
      message: "Beam MacOS success build",
      channel: "#webhooks",
      success: true,
      default_payloads: [:git_branch, :last_git_commit], # :test_result
      payload: {

      },
      attachment_properties: {
        fields: [
          title: "DMG",
          value: lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].first,
          short: false
        ],
      },
      slack_url: ENV["SLACK_WEBHOOK_URL"]
    )
  end

  lane :delete_s3 do |params|
    git_branch
    directory = Actions.git_branch

    unless ["HEAD", "master", "develop", "release"].include?(directory)
      s3 = Aws::S3::Resource.new(region: ENV["AWS_DEFAULT_REGION"],
                                 credentials: Aws::Credentials.new(ENV["AWS_ACCESS_KEY_ID"],
                                                                   ENV["AWS_SECRET_ACCESS_KEY"]))

      bucket = s3.bucket(ENV["S3_BUCKET"])
      UI.message "S3: deleting #{ENV["S3_BUCKET"]}/#{directory}"
      bucket.objects(prefix: directory).batch_delete!
      UI.success "S3: Removed #{ENV["S3_BUCKET"]}/#{directory}"
    end
  end

  lane :release do
    # sync_code_signing
    # disable_automatic_code_signing(path: "Beam.xcodeproj")
    # clear_derived_data
    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: "Beam release",
      silent: true,
      clean: true,
      output_directory: "builds",
      include_symbols: false,
      export_method: "developer-id", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id
      # export_xcargs: "-allowProvisioningUpdates"
      # mac_app_installer_cert_name: "foobar"
    )
    # enable_automatic_code_signing(path: "Beam.xcodeproj")
  end
end
