# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:mac)
xcversion(version: ENV["XCODE_VERSION"])

platform :mac do
  desc "Run linting"
  lane :lint do
    cocoapods
    swiftlint(
      executable: './Pods/SwiftLint/swiftlint',
      mode: :lint,
      strict: true,
      config_file: '.swiftlint.yml',
      reporter: "json",
      output_file: "fastlane/swiftlint.json",
    )
  end

  desc "Register Device"
  lane :register_local_device do
    register_device(
      name: `hostname | cut -d'.' -f1`,
      udid: `ioreg -ad2 -c IOPlatformExpertDevice | xmllint --xpath '//key[.="IOPlatformUUID"]/following-sibling::*[1]/text()' -`,
      team_id: ENV["TEAM_ID"],
      username: ENV["CERT_USERNAME"]
    )
  end

  private_lane :check_certs do |params|
    # Parameters at https://docs.fastlane.tools/actions/cert/
    get_certificates(
      development: params[:cert_development],
      force: false,
      type: params[:cert_type],
      # Don't set the filename so we can easily see which certificate is used
      # Proper one should be 68DY6473LM for Fabien penso
      # You can see its value at https://developer.apple.com/account/resources/certificates/list inside the certificate url
      # filename: "developer_id.cer",
      output_path: "./certs",
      username: ENV["CERT_USERNAME"],
      team_id: ENV["TEAM_ID"],
      team_name: ENV["TEAM_NAME"],
      platform: "macos"
    )

    # Parameters at https://docs.fastlane.tools/actions/sigh/
    get_provisioning_profile(
      development: params[:profile_development],
      developer_id: params[:profile_developer_id],
      username: ENV["CERT_USERNAME"],
      app_identifier: ENV["TEAM_IDENTIFIER"],
      team_id: ENV["TEAM_ID"],
      team_name: ENV["TEAM_NAME"],
      provisioning_name: params[:profile_provision_name],
      cert_id: params[:profile_cert_id],
      cert_owner_name: ENV["CERT_OWNER_NAME"],
      skip_certificate_verification: true,
      platform: "macos",
      output_path: "./certs",
      # Actually should be .profileprovision but fastlane complains. It will
      # automatically fetch this profile, but you can just get the one from
      # working md5sum: 5c00f51fe03c198182f31980df51a219
      filename: params[:profile_filename],
      readonly: true, # Don't want to mess up mine
      # force: false,
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Beam.xcodeproj",
      team_id: ENV["TEAM_ID"],
      code_sign_identity: params[:code_sign_identity],
      profile_name: params[:profile_name],
      bundle_identifier: ENV["TEAM_IDENTIFIER"],
      targets: ["Beam"],
      build_configurations: params[:build_configurations])
  end

  desc "Run tests"
  lane :tests do
    check_certs(profile_development: true,
                cert_development: true,
                profile_provision_name: "Beam Development",
                profile_cert_id: "68DY6473LM",
                profile_filename: "development.co.beamapp.macos.mobileprovision",
                code_sign_identity: "Mac Developer",
                profile_name: "Beam Development",
                build_configurations: ["Debug"])
    cocoapods
    run_tests(
      scheme: "Beam",
      output_types: "junit",
      output_files: "tests.xml"
    )
    # For Gitlab artifacts
    slather(
      cobertura_xml: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
    # For automatic code coverage check
    slather(
      simple_output: true,
      workspace: "Beam.xcworkspace",
      proj: "Beam.xcodeproj",
      scheme: "Beam",
      source_directory: "./Beam",
      output_directory: "./"
    )
  end

  ## To release developer version
  lane :dev do
    check_certs(profile_development: true)
    cocoapods

    git_branch

    UI.message "Branch is #{Actions.git_branch}"
    if Actions.git_branch != "master"
      add_badge(dark: true,
                grayscale: true,
                glob: "/Beam/Assets/Assets.xcassets/AppIcon.appiconset/*.png")
    end

    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: "Beam",
      silent: true,
      clean: true,
      output_directory: "builds",
      output_name: "Beam",
      include_symbols: true,
      # xcargs: settings_to_override,
      # Doesn't work :(
      export_xcargs: 'OTHER_CODE_SIGN_FLAGS="--timestamp"',
      export_method: "development", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id
      export_options: "./ExportOptions.plist",
      # Found this at https://github.com/fastlane/fastlane/issues/15963 or we have archive failed
      skip_package_pkg: true
    )
  end

  ## To release DeveloperId signed builds
  lane :beta do
    git_branch
    # Let's do version increment manually in Xcode
    # increment_version_number(bump_type: "patch")
    # Sadly we can't use anything out of a number for building number, so we
    # can't include the current branch. The following fails:
    # build_number = "#{Actions.git_branch}/#{ENV['CI_JOB_ID']}".gsub(/\//, "-")

    build_number = ENV['CI_JOB_ID']
    increment_build_number(build_number: build_number)
    appcast_url = "https://s3.eu-west-3.amazonaws.com/downloads.dev.beamapp.co/#{Actions.git_branch}/appcast.xml"
    info_plist = "Beam/Configuration/Info.plist"

    UI.message "Set appcast url to #{appcast_url} in #{info_plist}"

    sparkle_set_url(info_plist: info_plist,
                    appcast_url: appcast_url)

    check_certs(cert_development: false,
                cert_type: "developer_id_application",
                profile_filename: "developer_id.co.beamapp.macos.mobileprovision",
                profile_developer_id: true,
                profile_provision_name: ENV["PROVISION_NAME"],
                profile_cert_id: ENV["CERT_ID"],
                code_sign_identity: "Developer ID Application",
                profile_name: ENV["PROVISION_NAME"],
                build_configurations: ["Release"])

    cocoapods

    UI.message "Branch is #{Actions.git_branch}"
    if Actions.git_branch != "master"
      add_badge(dark: true,
                grayscale: true,
                glob: "/Beam/Assets/Assets.xcassets/AppIcon.appiconset/*.png")
    end

    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: ENV["SCHEME"],
      silent: true,
      clean: true,
      output_directory: "builds",
      output_name: "Beam",
      include_symbols: false,
      # xcargs: settings_to_override,
      # Doesn't work :(
      export_xcargs: 'OTHER_CODE_SIGN_FLAGS="--timestamp"',

      export_method: "developer-id", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id

      ## Doesn't work but it should :(
      #      export_options: {
      #        method: "development",
      #        provisioningProfiles: {
      #          "co.beamapp.macos" => "Beam"
      #        }
      #      }
      ## But this works
      export_options: "./ExportOptionsDeveloperId.plist",
      # Found this at https://github.com/fastlane/fastlane/issues/15963 or we have archive failed
      skip_package_pkg: true

      # export_xcargs: "-allowProvisioningUpdates"
    )
  end

  lane :notarize_build do
    # https://blog.zeplin.io/dev-journal-automate-notarizing-macos-apps-94b0b144ba9d
    notarize(
      package: "builds/Beam.dmg",
      verbose: true,
      print_log: true,
      bundle_id: ENV["APP_IDENTIFIER"]
    )
  end

  lane :deploy do
    upload_s3
    ping_slack
  end

  lane :ping_sentry do
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")

    sentry_upload_dsym(
      org_slug: "beamapp",
      project_slug: "beam-macos",
      dsym_path: "builds/Beam.app.dSYM.zip"
    )

    sentry_create_release(
      org_slug: "beamapp",
      project_slug: "beam-macos",
      version: "#{lane_context[SharedValues::VERSION_NUMBER]}+#{lane_context[SharedValues::BUILD_NUMBER]}",
      app_identifier: ENV["TEAM_IDENTIFIER"],
      finalize: true
    )

#    sentry_set_commits(
#      version: lane_context[SharedValues::BUILD_NUMBER],
#      app_identifier: ENV["TEAM_IDENTIFIER"],
#      auto: false, # enable completely automated commit management
#      clear: false, # clear all current commits from the release
#      commit: '...', # commit spec, see `sentry-cli releases help set-commits` for more information
#    )
  end

  private_lane :create_release_notes do
    # Fetch commit from S3 if we already had one
    download_previous_file(filename: "commit")

    changelog = if File.exists?("../builds/commit")
                  last_commit = File.read("../builds/commit").chomp
                  UI.message "Previous commit file exists, using `git log HEAD...#{last_commit}`"
                  `git log HEAD...#{last_commit}`
                else
                  UI.message "No previous commit file, using `git log -1`"
                  `git log -1`
                end

    File.open("../builds/release_notes.html", "wb") do |f|
      f.write("<html><body><pre>#{changelog}</pre></body></html>")
    end

    # Store this commit
    File.open("../builds/commit", "wb") do |f|
      current_commit = `git rev-parse HEAD`.chomp
      UI.message "Storing current commit #{current_commit} for next release notes"
      f.write(current_commit)
    end
  end

  lane :upload_s3 do
    # We want the build number from `builds/Beam.app/Contents/Info.plist`
    # get_version_number
    # get_build_number
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    git_branch

    create_release_notes

    # appcast.xml should be in `master/appcast.xml` on S3, not `master/build/rev/appcast.xml`
    upload_appcast

    s3_path = if Actions.git_branch == "master"
                "#{Actions.git_branch}/#{lane_context[SharedValues::VERSION_NUMBER]}/#{lane_context[SharedValues::BUILD_NUMBER]}"
              else
                Actions.git_branch
              end

    # This should be last upload, or Slack links will be wrong
    aws_s3(
      access_key: ENV["AWS_ACCESS_KEY_ID"],
      secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"],
      bucket: ENV["S3_BUCKET"],
      region: ENV["AWS_DEFAULT_REGION"],
      upload_metadata: true,
      files: [
        "builds/Beam.dmg",
        "builds/Beam.app.dSYM.zip",
        "builds/release_notes.html"
      ],
      # Doesn't work the way I expected
      # endpoint: "http://downloads.dev.beamapp.co",
      path: s3_path
    )

    lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].each do |file|
      UI.success "S3: #{file}"
    end
  end

  private_lane :upload_appcast do
    # I have to do Sparkle at the same time, as `increment_build_number`
    # modifies Beam/Configuration/Info.plist but this file is not propagated to
    # other CI jobs
    download_previous_file(filename: "appcast.xml", default_file: "appcast.xml")
    generate_sparkle_feed

    git_branch
    s3_path = Actions.git_branch

    aws_s3(
      access_key: ENV["AWS_ACCESS_KEY_ID"],
      secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"],
      bucket: ENV["S3_BUCKET"],
      region: ENV["AWS_DEFAULT_REGION"],
      upload_metadata: true,
      files: [
        "builds/appcast.xml",
        "builds/commit"
      ],
      # Doesn't work the way I expected
      # endpoint: "http://downloads.dev.beamapp.co",
      path: s3_path
    )

    lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].each do |file|
      UI.success "S3: #{file}"
    end
  end

  private_lane :download_previous_file do |params|
    git_branch

    filename = params[:filename]
    default_file = params[:default_file]

    s3_path = if Actions.git_branch == "master"
                "#{Actions.git_branch}/#{lane_context[SharedValues::VERSION_NUMBER]}/#{lane_context[SharedValues::BUILD_NUMBER]}"
              else
                Actions.git_branch
              end

    s3_client = Aws::S3::Client.new(region: ENV["AWS_DEFAULT_REGION"],
                                   access_key_id: ENV["AWS_ACCESS_KEY_ID"],
                                   secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"])

    s3_client.get_object(
      response_target: "../builds/#{filename}",
      bucket: ENV["S3_BUCKET"],
      key: "#{s3_path}/#{filename}"
    )
    UI.success "S3: Fetched https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}/#{filename}"
  rescue Aws::S3::Errors::NoSuchKey => e
    UI.message "S3: https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}/#{filename} does not exist"
    if default_file
      FileUtils.cp(default_file, "../builds/#{filename}")
    end
  rescue
    UI.error "S3: Error fetching #{s3_path}/#{filename}: #{$!}"
    raise $!
  end

  private_lane :generate_sparkle_feed do |params|
    get_version_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    get_build_number_from_plist(info_plist: "builds/Beam.app/Contents/Info.plist")
    git_branch

    s3_path = if Actions.git_branch == "master"
                "#{Actions.git_branch}/#{lane_context[SharedValues::VERSION_NUMBER]}/#{lane_context[SharedValues::BUILD_NUMBER]}"
              else
                Actions.git_branch
              end

    directory = "https://s3.#{ENV['AWS_DEFAULT_REGION']}.amazonaws.com/#{ENV['S3_BUCKET']}/#{s3_path}"
    app_download_url = "#{directory}/Beam.dmg"
    release_notes_html_url = "#{directory}/release_notes.html"
    human_version = "#{lane_context[SharedValues::VERSION_NUMBER]}"
    machine_version = "#{lane_context[SharedValues::BUILD_NUMBER]}"
    release_title = "Version #{human_version}"

    sparkle_add_update(
      feed_file: "builds/appcast.xml",
      app_download_url: app_download_url,
      app_size: "#{File.size("../builds/Beam.dmg")}",
      machine_version: machine_version,
      human_version: human_version,
      title: release_title,
      release_notes_link: release_notes_html_url,
    )

    UI.success "Sparkle: Successfully added a release item to the Appcast XML file"
    UI.success "Sparkle: Added #{human_version} #{machine_version} at #{app_download_url}"
  end

  private_lane :ping_slack do
    git_branch

    next unless ["HEAD", "master"].include?(Actions.git_branch)

    attachments = lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].map do |file|
      {
        title_link: file,
        fallback: file
      }
    end

    slack(
      message: "Beam MacOS success build",
      channel: "#webhooks",
      success: true,
      default_payloads: [:git_branch, :last_git_commit], # :test_result
      payload: {

      },
      attachment_properties: {
        fields: [
          title: "DMG",
          value: lane_context[SharedValues::S3_FILES_OUTPUT_PATHS].first,
          short: false
        ],
      },
      slack_url: ENV["SLACK_WEBHOOK_URL"]
    )
  end

  lane :delete_s3 do
    git_branch
    directory = Actions.git_branch

    unless ["HEAD", "master"].include?(directory)
      s3 = Aws::S3::Resource.new(region: ENV["AWS_DEFAULT_REGION"],
                                 credentials: Aws::Credentials.new(ENV["AWS_ACCESS_KEY_ID"],
                                                                   ENV["AWS_SECRET_ACCESS_KEY"]))

      bucket = s3.bucket(ENV["S3_BUCKET"])
      UI.message "S3: deleting #{ENV["S3_BUCKET"]}/#{directory}"
      bucket.objects(prefix: directory).batch_delete!
      UI.success "S3: Removed #{ENV["S3_BUCKET"]}/#{directory}"
    end
  end

  lane :release do
    # sync_code_signing
    # disable_automatic_code_signing(path: "Beam.xcodeproj")
    # clear_derived_data
    cocoapods
    build_mac_app(
      workspace: "Beam.xcworkspace",
      scheme: "Beam release",
      silent: true,
      clean: true,
      output_directory: "builds",
      include_symbols: false,
      export_method: "developer-id", # Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id
      # export_xcargs: "-allowProvisioningUpdates"
      # mac_app_installer_cert_name: "foobar"
    )
    # enable_automatic_code_signing(path: "Beam.xcodeproj")
  end
end
