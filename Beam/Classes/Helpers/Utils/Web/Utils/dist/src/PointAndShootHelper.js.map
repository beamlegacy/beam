{"version":3,"file":"PointAndShootHelper.js","sourceRoot":"","sources":["../../src/PointAndShootHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BeamCoordinates,\n  BeamElement,\n  BeamHTMLElement,\n  BeamMouseLocation,\n  BeamNode,\n  BeamNodeType,\n  BeamRange,\n  BeamRangeGroup,\n  BeamSelection,\n  BeamShootGroup,\n  BeamText,\n  BeamWindow\n} from \"@beam/native-beamtypes\"\nimport { BeamElementHelper } from \"./BeamElementHelper\"\nimport { BeamEmbedHelper } from \"./BeamEmbedHelper\"\n\nexport class PointAndShootHelper {\n  /**\n   * Check if string matches any items in array of strings. For a minor performance\n   * improvement we check first if the string is a single character.\n   *\n   * @static\n   * @param {string} text\n   * @return {*}  {boolean} true if text matches\n   * @memberof PointAndShootHelper\n   */\n  static isOnlyMarkupChar(text: string): boolean {\n    if (text.length == 1) {\n      return [\"•\", \"-\", \"|\", \"–\", \"—\", \"·\"].includes(text)\n    } else {\n      return false\n    }\n  }\n  /**\n   * Returns whether or not a text is deemed useful enough as a single unit\n   * we should be very cautious with what we filter out, so instead of relying\n   * on the text length > 1 char we're just having a blacklist of characters\n   *\n   * @param text\n   */\n  static isTextMeaningful(text: string): boolean {\n    if (text) {\n      const trimmed = text.trim()\n      return !!trimmed && !this.isOnlyMarkupChar(trimmed)\n    }\n    return false\n  }\n  /**\n   * Checks if an element meets the requirements to be considered meaningful\n   * to be included within the highlighted area. An element is meaningful if\n   * it's visible and if it's either an image or it has at least some actual\n   * text content\n   *\n   * @param element\n   * @param win\n   */\n  static isMeaningful(element: BeamElement, win: BeamWindow): boolean {\n    const embedHelper = new BeamEmbedHelper(win)\n    return (\n      (embedHelper.isEmbeddableElement(element) ||\n        BeamElementHelper.isMedia(element) ||\n        BeamElementHelper.isImageContainer(element, win) ||\n        PointAndShootHelper.isTextMeaningful(BeamElementHelper.getTextValue(element))) &&\n      BeamElementHelper.isVisible(element, win)\n    )\n  }\n  /**\n   * Returns true if element matches a known html to ignore on specific urls.\n   *\n   * @static\n   * @param {BeamElement} element\n   * @param {BeamWindow} win\n   * @return {*}  {boolean} true if element should be ignored\n   * @memberof PointAndShootHelper\n   */\n  static isUselessSiteSpecificElement(element: BeamElement, win: BeamWindow): boolean {\n    // Amazon Magnifier\n    if (win.location.hostname?.includes(\"amazon.\") && element.id == \"magnifierLens\") {\n      return true\n    }\n\n    return false\n  }\n  /**\n   * Recursively check for the presence of any meaningful child nodes within a given element\n   *\n   * @static\n   * @param {BeamElement} element The Element to query\n   * @param {BeamWindow} win\n   * @return {*}  {boolean} Boolean if element or any of it's children are meaningful\n   * @memberof PointAndShootHelper\n   */\n  static isMeaningfulOrChildrenAre(element: BeamElement, win: BeamWindow): boolean {\n    if (PointAndShootHelper.isMeaningful(element, win)) {\n      return true\n    }\n    return [...element.children].some((child) => PointAndShootHelper.isMeaningful(child, win))\n  }\n  /**\n   * Recursively check for the presence of any meaningful child nodes within a given element.\n   *\n   * @static\n   * @param {BeamElement} element The Element to query\n   * @param {BeamWindow} win\n   * @return {*}  {BeamNode[]} return the element's meaningful child nodes\n   * @memberof PointAndShootHelper\n   */\n  static getMeaningfulChildNodes(element: BeamElement, win: BeamWindow): BeamNode[] {\n    return [...element.childNodes].filter(\n      (child) =>\n        (child.nodeType === BeamNodeType.element &&\n          PointAndShootHelper.isMeaningfulOrChildrenAre(child as BeamElement, win)) ||\n        (child.nodeType === BeamNodeType.text && PointAndShootHelper.isTextMeaningful((child as BeamText).data))\n    )\n  }\n  /**\n   * Recursively check for the presence of any Useless child nodes within a given element\n   *\n   * @static\n   * @param {BeamElement} element The Element to query\n   * @param {BeamWindow} win\n   * @return {*}  {boolean} Boolean if element or any of it's children are Useless\n   * @memberof PointAndShootHelper\n   */\n  static isUselessOrChildrenAre(element: BeamElement, win: BeamWindow): boolean {\n    return PointAndShootHelper.isMeaningfulOrChildrenAre(element, win) == false\n  }\n  /**\n   * Get all child nodes of type element or text\n   *\n   * @static\n   * @param {BeamElement} element\n   * @param {BeamWindow} win\n   * @return {*}  {BeamNode[]}\n   * @memberof PointAndShootHelper\n   */\n  static getElementAndTextChildNodesRecursively(element: BeamElement, win: BeamWindow): BeamNode[] {\n    if (!element?.childNodes) {\n      return [element]\n    }\n\n    const nodes = [];\n\n    [...element.childNodes].forEach((child) => {\n      switch (child.nodeType) {\n        case BeamNodeType.element:\n          nodes.push(child)\n          // eslint-disable-next-line no-case-declarations\n          const childNodesOfChild = this.getElementAndTextChildNodesRecursively(child as BeamElement, win)\n          nodes.push(...childNodesOfChild)\n          break\n        case BeamNodeType.text:\n          nodes.push(child)\n          break\n        default:\n          break\n      }\n    })\n\n    if (nodes.length == 0) {\n      return [element]\n    }\n\n    return nodes\n  }\n\n  /**\n   * Returns true if only the altKey is pressed. Alt is equal to Option is MacOS.\n   *\n   * @static\n   * @param {*} ev\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isOnlyAltKey(ev): boolean {\n    const altKey = ev.altKey || ev.key == \"Alt\"\n    return altKey && !ev.ctrlKey && !ev.metaKey && !ev.shiftKey\n  }\n\n  static upsertShootGroup(newItem: BeamShootGroup, groups: BeamShootGroup[]): void {\n    // Update existing rangeGroup\n    const index = groups.findIndex(({ element }) => {\n      return element == newItem.element\n    })\n    if (index != -1) {\n      groups[index] = newItem\n    } else {\n      groups.push(newItem)\n    }\n  }\n\n  static upsertRangeGroup(newItem: BeamRangeGroup, groups: BeamRangeGroup[]): void {\n    // Update existing rangeGroup\n    const index = groups.findIndex(({ id }) => {\n      return id == newItem.id\n    })\n    if (index != -1) {\n      groups[index] = newItem\n    } else {\n      groups.push(newItem)\n    }\n  }\n  /**\n   * Returns true when the target has `contenteditable=\"true\"` or `contenteditable=\"plaintext-only\"`\n   *\n   * @static\n   * @param {BeamHTMLElement} target\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isExplicitlyContentEditable(target: BeamHTMLElement): boolean {\n    return [\"true\", \"plaintext-only\"].includes(BeamElementHelper.getContentEditable(target))\n  }\n  /**\n   * Check for inherited contenteditable attribute value by traversing\n   * the ancestors until an explicitly set value is found\n   *\n   * @param element {(BeamNode)} The DOM node to check.\n   * @return If the element inherits from an actual contenteditable valid values\n   *         (\"true\", \"plaintext-only\")\n   */\n  static getInheritedContentEditable(element: BeamHTMLElement): boolean {\n    let isEditable = this.isExplicitlyContentEditable(element)\n    const parent = element.parentElement as BeamHTMLElement\n    if (parent && BeamElementHelper.getContentEditable(element) === \"inherit\") {\n      isEditable = this.getInheritedContentEditable(parent)\n    }\n    return isEditable\n  }\n  /**\n   * Returns true when target is a text input. Specificly when either of these conditions is true:\n   *  - The target is an text <input> tag\n   *  - The target or it's parent element is contentEditable\n   *\n   * @static\n   * @param {BeamHTMLElement} target\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isTargetTextualInput(target: BeamHTMLElement): boolean {\n    return BeamElementHelper.isTextualInputType(target) || this.getInheritedContentEditable(target)\n  }\n\n  /**\n   * Returns true when the Target element is the activeElement. It always returns false when the target Element is the document body.\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @param {BeamHTMLElement} target\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isEventTargetActive(win: BeamWindow, target: BeamHTMLElement): boolean {\n    return !!(\n      win.document.activeElement &&\n      win.document.activeElement !== win.document.body &&\n      win.document.activeElement.contains(target)\n    )\n  }\n  /**\n   * Returns true when the Target Text Element is the activeElement (The current element with \"Focus\")\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @param {BeamHTMLElement} target\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isActiveTextualInput(win: BeamWindow, target: BeamHTMLElement): boolean {\n    return this.isEventTargetActive(win, target) && this.isTargetTextualInput(target)\n  }\n  /**\n   * Checks if the MouseLocation Coordinates has changed from the provided X or Y Coordinates. Returns true when either X or Y is different\n   *\n   * @static\n   * @param {BeamMouseLocation} mouseLocation\n   * @param {number} clientX\n   * @param {number} clientY\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static hasMouseLocationChanged(mouseLocation: BeamMouseLocation, clientX: number, clientY: number): boolean {\n    return mouseLocation?.x !== clientX || mouseLocation?.y !== clientY\n  }\n  /**\n   * Returns true when the current document has an Text Input or ContentEditable element as activeElement (The current element with \"Focus\")\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static hasFocusedTextualInput(win: BeamWindow): boolean {\n    const target = win.document.activeElement as unknown as BeamHTMLElement\n    if (target) {\n      return  BeamElementHelper.isTextualInputType(target) || this.getInheritedContentEditable(target)\n    } else {\n      return false\n    }\n  }\n  /**\n   * Returns true when Pointing should be disabled. It checks if any of the following is true:\n   *  - The event is on an active Text Input\n   *  - The document has a focussed Text Input\n   *  - The document has an active Text Selection\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @param {BeamHTMLElement} target\n   * @return {*}  {boolean}\n   * @memberof PointAndShootHelper\n   */\n  static isPointDisabled(win: BeamWindow, target: BeamHTMLElement): boolean {\n    return this.isActiveTextualInput(win, target) || this.hasFocusedTextualInput(win) || this.hasSelection(win)\n  }\n  /**\n   * Returns boolean if document has active selection\n   */\n  static hasSelection(win: BeamWindow): boolean {\n    return !win.document.getSelection().isCollapsed && Boolean(win.document.getSelection().toString())\n  }\n  /**\n   * Returns an array of ranges for a given HTML selection\n   *\n   * @param {BeamSelection} selection\n   * @return {*}  {BeamRange[]}\n   */\n  static getSelectionRanges(selection: BeamSelection): BeamRange[] {\n    const ranges = []\n    const count = selection.rangeCount\n    for (let index = 0; index < count; ++index) {\n      const range = selection.getRangeAt(index)\n      ranges.push(range)\n    }\n    return ranges\n  }\n  /**\n   * Returns the current active (text) selection on the document\n   *\n   * @return {BeamSelection}\n   */\n  static getSelection(win: BeamWindow): BeamSelection {\n    return win.document.getSelection()\n  }\n  /**\n   * Returns the HTML element under the current Mouse Location Coordinates\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @param {BeamMouseLocation} mouseLocation\n   * @return {*}  {BeamHTMLElement}\n   * @memberof PointAndShootHelper\n   */\n  static getElementAtMouseLocation(win: BeamWindow, mouseLocation: BeamMouseLocation): BeamHTMLElement {\n    return win.document.elementFromPoint(mouseLocation.x, mouseLocation.y)\n  }\n\n  static getOffset(object: BeamElement, offset: BeamCoordinates): void {\n    if (object) {\n      offset.x += object.offsetLeft\n      offset.y += object.offsetTop\n      PointAndShootHelper.getOffset(object.offsetParent, offset)\n    }\n  }\n\n  static getScrolled(object: BeamElement, scrolled: BeamCoordinates): void {\n    if (object) {\n      scrolled.x += object.scrollLeft\n      scrolled.y += object.scrollTop\n      if (object.tagName.toLowerCase() != \"html\") {\n        PointAndShootHelper.getScrolled(object.parentNode as BeamElement, scrolled)\n      }\n    }\n  }\n\n  /**\n   * Get top left X, Y coordinates of element taking into acocunt the scroll position \n   *\n   * @static\n   * @param {BeamElement} el\n   * @return {*}  {BeamCoordinates}\n   * @memberof Util\n   */\n  static getTopLeft(el: BeamElement): BeamCoordinates {\n    const offset = { x: 0, y: 0 }\n    PointAndShootHelper.getOffset(el, offset)\n\n    const scrolled = { x: 0, y: 0 }\n    PointAndShootHelper.getScrolled(el.parentNode as BeamElement, scrolled)\n\n    const x = offset.x - scrolled.x\n    const y = offset.y - scrolled.y\n    return { x, y }\n  }\n\n  /**\n   * Return value clamped between min and max\n   *\n   * @static\n   * @param {number} val\n   * @param {number} min\n   * @param {number} max\n   * @return {number}\n   * @memberof Util\n   */\n  static clamp(val: number, min: number, max: number): number {\n    return val > max ? max : val < min ? min : val\n  }\n\n  /**\n   * Remove null and undefined from array\n   *\n   * @static\n   * @param {unknown[]} array\n   * @return {*}  {any[]}\n   * @memberof Util\n   */\n  static compact(array: any[]): any[] {\n    return array.filter((item) => {\n      return item != null\n    })\n  }\n\n  /**\n   * Check if number is in range\n   *\n   * @static\n   * @param {number} number The number to check.\n   * @param {number} start The start of the range.\n   * @param {number} end The end of the range.\n   * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n   * @memberof Util\n   */\n  static isNumberInRange(number: number, start: number, end: number): boolean {\n    return Number(number) >= Math.min(start, end) && number <= Math.max(start, end)\n  }\n\n  /**\n   * Maps value, from range to range\n   *\n   * For example mapping 10 degrees Celcius to Fahrenheit\n   * `mapRangeToRange([0, 100], [32, 212], 10)`\n   *\n   * @static\n   * @param {[number, number]} from\n   * @param {[number, number]} to\n   * @param {number} s\n   * @return {*}  {number}\n   * @memberof Util\n   */\n  static mapRangeToRange(from: [number, number], to: [number, number], s: number): number {\n    return to[0] + ((s - from[0]) * (to[1] - to[0])) / (from[1] - from[0])\n  }\n\n  /**\n   * Generates a good enough non-compliant UUID.\n   *\n   * @static\n   * @param {BeamWindow} win\n   * @return {*}  {string}\n   * @memberof Util\n   */\n  static uuid(win: BeamWindow<any>): string {\n    const buf = new Uint32Array(4)\n    return win.crypto.getRandomValues(buf).join(\"-\")\n  }\n\n  /**\n   * Remove first matched item from array, Uses findIndex under the hood.\n   *\n   * @static\n   * @param {(arrayElement) => boolean} matcher when matcher returns true that item is removed from array\n   * @param {unknown[]} array input array\n   * @return {*}  {unknown[]} return updated array\n   * @memberof Util\n   */\n  static removeFromArray(matcher: (arrayElement) => boolean, array: unknown[]): unknown[] {\n    const foundIndex = array.findIndex(matcher)\n    // foundIndex is -1 when no match is found. Only remove found items from array\n    if (foundIndex >= 0) {\n      array.splice(foundIndex, 1)\n    }\n\n    return array\n  }\n}\n"]}