{"version":3,"file":"BeamRectHelper.js","sourceRoot":"","sources":["../../src/BeamRectHelper.ts"],"names":[],"mappings":";;;AAEA,MAAa,cAAc;IAEzB,MAAM,CAAC,0BAA0B,CAAC,WAAuB,EAAE,WAAuB;QAChF,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACvC,mDAAmD;YACnD,OAAO,IAAI,CAAC,yBAAyB,CAAC,UAAU,EAAE,WAAW,CAAC,IAAI,KAAK,CAAA;QACzE,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,MAAM,CAAC,yBAAyB,CAAC,UAAoB,EAAE,WAAuB;QAC5E,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE;YACnC,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAA;QACpD,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,MAAM,CAAC,YAAY,CAAC,KAAe,EAAE,KAAe;QAClD,OAAO,CACL,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,MAAM,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,MAAM,CAAC;YACtD,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,CAAC,CACrD,CAAA;IACH,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,YAAY,CAAC,KAAe,EAAE,KAAe;QAClD,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAA;QACpC,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAA;QACpC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACxE,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAC3E,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;IAChC,CAAC;IAED;;;;;;;;OAQG;IACH,MAAM,CAAC,YAAY,CAAC,KAAe,EAAE,KAAe;QAClD,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAA;QACpC,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAA;QAEpC,kFAAkF;QAClF,kFAAkF;QAClF,MAAM,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;QACrF,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,CAAA;QAC/B,MAAM,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;QACvF,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,CAAA;QAE/B,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACpB,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE,GAAG,CAAC,EAAE,CAAA;SAC/C;IACH,CAAC;CACF;AA9DD,wCA8DC","sourcesContent":["import {BeamRect} from \"@beam/native-beamtypes\"\n\nexport class BeamRectHelper {\n\n  static filterRectArrayByRectArray(sourceArray: BeamRect[], filterArray: BeamRect[]): BeamRect[] {\n    return sourceArray.filter((sourceRect) => {\n      // When rect matches array return true to filter it\n      return this.doRectMatchesRectsInArray(sourceRect, filterArray) == false\n    })\n  }\n  \n  static doRectMatchesRectsInArray(sourceRect: BeamRect, filterArray: BeamRect[]): boolean {\n    return filterArray.some((filterRect) => {\n        return this.doRectsMatch(sourceRect, filterRect)\n    })\n  }\n\n  static doRectsMatch(rect1: BeamRect, rect2: BeamRect): boolean {\n    return (\n      Math.round(rect1?.x) == Math.round(rect2?.x) &&\n      Math.round(rect1?.y) == Math.round(rect2?.y) &&\n      Math.round(rect1?.height) == Math.round(rect2?.height) &&\n      Math.round(rect1?.width) == Math.round(rect2?.width)\n    )\n  }\n\n  /**\n   * Return the bounding rectangle for two given rectangles\n   *\n   * @param rect1\n   * @param rect2\n   */\n  static boundingRect(rect1: BeamRect, rect2: BeamRect): BeamRect {\n    const x = Math.min(rect1.x, rect2.x)\n    const y = Math.min(rect1.y, rect2.y)\n    const width = Math.max(rect1.x + rect1.width, rect2.x + rect2.width) - x\n    const height = Math.max(rect1.y + rect1.height, rect2.y + rect2.height) - y\n    return { x, y, width, height }\n  }\n\n  /**\n   * Get the intersection of two given rectangles, the rectangles can have infinite dimensions\n   * (for instance when `x` and `width` properties are respectively -Infinity and Infinity)\n   *\n   * @param rect1\n   * @param rect2\n   * @return {BeamRect} if the intersection is defined\n   * @return undefined when no intersection exist\n   */\n  static intersection(rect1: BeamRect, rect2: BeamRect): BeamRect {\n    const x = Math.max(rect1.x, rect2.x)\n    const y = Math.max(rect1.y, rect2.y)\n\n    // rects can have Infinite dimensions, in which case have to filter out NaN values\n    // since -Infinity + Infinity is NaN (rect.x + rect.width or rect.y + rect.height)\n    const validX2 = [rect1.x + rect1.width, rect2.x + rect2.width].filter(v => !isNaN(v))\n    const x2 = Math.min(...validX2)\n    const validY2 = [rect1.y + rect1.height, rect2.y + rect2.height].filter(v => !isNaN(v))\n    const y2 = Math.min(...validY2)\n\n    if (x2 > x && y2 > y) {\n      return { x, y, width: x2 - x, height: y2 - y }\n    }\n  }\n}\n"]}