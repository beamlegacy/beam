{"version":3,"file":"BeamElementHelper.js","sourceRoot":"","sources":["../../src/BeamElementHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BeamElement,\n  BeamHTMLElement,\n  BeamHTMLInputElement,\n  BeamHTMLTextAreaElement,\n  BeamRect,\n  BeamWindow\n} from \"@beam/native-beamtypes\"\nimport {BeamRectHelper} from \"./BeamRectHelper\"\nimport { BeamEmbedHelper } from \"./BeamEmbedHelper\"\n\n/**\n * Useful methods for HTML Elements\n */\nexport class BeamElementHelper {\n  static getAttribute(attr: string, element: BeamElement): string {\n    const attribute = element.attributes.getNamedItem(attr)\n    return attribute?.value\n  }\n\n  static getType(element: BeamElement): string {\n    return BeamElementHelper.getAttribute(\"type\", element)\n  }\n\n  static getContentEditable(element: BeamElement): string {\n    return BeamElementHelper.getAttribute(\"contenteditable\", element) || \"inherit\"\n  }\n\n  /**\n   * Returns if an element is a textarea or an input elements with a text\n   * based input type (text, email, date, number...)\n   *\n   * @param element {BeamHTMLElement} The DOM Element to check.\n   * @return If the element is some kind of text input.\n   */\n  static isTextualInputType(element: BeamHTMLElement): boolean {\n    const tag = element.tagName.toLowerCase()\n    if (tag === \"textarea\") {\n      return true\n    } else if (tag === \"input\") {\n      const types = [\n        \"text\", \"email\", \"password\",\n        \"date\", \"datetime-local\", \"month\",\n        \"number\", \"search\", \"tel\",\n        \"time\", \"url\", \"week\",\n        // for legacy support\n        \"datetime\"\n      ]\n      return types.includes((element as BeamHTMLInputElement).type)\n    }\n    return false\n  }\n\n  /**\n   * Returns the text value for a given element, text value meaning either\n   * the element's innerText or the input value\n   *\n   * @param el\n   */\n  static getTextValue(el: BeamElement): string {\n    let textValue\n    const tagName = el.tagName.toLowerCase()\n    switch (tagName) {\n      case \"input\": {\n        const inputEl = el as BeamHTMLInputElement\n        if (BeamElementHelper.isTextualInputType(inputEl)) {\n          textValue = inputEl.value\n        }\n      }\n        break\n      case \"textarea\":\n        textValue = (el as BeamHTMLTextAreaElement).value\n        break\n      default:\n        textValue = (el as BeamHTMLElement).innerText\n    }\n    return textValue\n  }\n\n  static getBackgroundImageURL(element: BeamElement, win: BeamWindow): string | null {\n    const style = win.getComputedStyle?.(element)\n    const matchArray = style?.backgroundImage.match(/url\\(([^)]+)/)\n    if (matchArray && matchArray.length > 1) {\n      return matchArray[1].replace(/('|\")/g,\"\")\n    }\n  }\n\n  /**\n   * Returns parent of node type. Maximum allowed recursive depth is 10\n   *\n   * @static\n   * @param {BeamElement} node target node to start at\n   * @param {string} type parent type to search for\n   * @param {number} [count=10] maximum depth of recursion, defaults to 10\n   * @return {*}  {(BeamElement | undefined)}\n   * @memberof BeamElementHelper\n   */\n  static hasParentOfType(element: BeamElement, type: string, count = 10): BeamElement | undefined {\n    if (count <= 0) return null\n    if (type !== \"BODY\" && element?.tagName === \"BODY\") return null\n    if (!element?.parentElement) return null\n    if (type === element?.tagName) return element\n    const newCount = count--\n    return BeamElementHelper.hasParentOfType(element.parentElement, type, newCount)\n  }\n  /**\n   * Parse Element based on it's styles and structure. Included conversions:\n   * - Convert background image element to img element\n   * - Wrapping element in anchor if parent is anchor tag\n   *\n   * @static\n   * @param {BeamElement} element\n   * @param {BeamWindow<any>} win\n   * @return {*}  {BeamHTMLElement}\n   * @memberof BeamElementHelper\n   */\n  static parseElementBasedOnStyles(element: BeamElement, win: BeamWindow<any>): BeamHTMLElement {\n    const embedHelper = new BeamEmbedHelper(win)\n    // If we support embedding on the current location\n    if (embedHelper.isEmbeddableElement(element)) {\n      // parse the element for embedding.\n      const embedElement = embedHelper.parseElementForEmbed(element)\n      if (embedElement) {\n        console.log(\"isEmbeddable\")\n        return embedElement\n      }\n    }\n\n    return element as BeamHTMLElement\n  }\n\n  /**\n   * Determine whether or not an element is visible based on it's style\n   * and bounding box if necessary\n   *\n   * @param element: {BeamElement}\n   * @param win: {BeamWindow}\n   * @return If the element is considered visible\n   */\n  // is slow, propertyvalue and boundingrect\n  static isVisible(element: BeamElement, win: BeamWindow<any>): boolean {\n    let visible = false\n\n    if (element) {\n      visible = true\n      // We start by getting the element's computed style to check for any smoking guns\n      const style = win.getComputedStyle?.(element)\n      if (style) {\n        visible = !(\n            style.getPropertyValue(\"display\") === \"none\"\n            // Maybe hidden shouldn't be filtered out see the opacity comment\n            || [\"hidden\", \"collapse\"].includes(style.getPropertyValue(\"visibility\"))\n            // The following heuristic isn't enough: twitter uses transparent inputs on top of their custom UI\n            // (see theme selector in display settings for an example)\n            // || style.opacity === '0'\n            || (style.getPropertyValue(\"width\") === \"1px\" && style.getPropertyValue(\"height\") === \"1px\")\n            || [\"0px\", \"0\"].includes(style.getPropertyValue(\"width\"))\n            || [\"0px\", \"0\"].includes(style.getPropertyValue(\"height\"))\n            // many clipPath values could cause the element to not be visible, but for now we only deal with single % values\n            || (\n                style.getPropertyValue(\"position\") === \"absolute\"\n                && style.getPropertyValue(\"clip\").match(/rect\\((0(px)?[, ]+){3}0px\\)/)\n            )\n            || style.getPropertyValue(\"clip-path\").match(/inset\\(([5-9]\\d|100)%\\)/)\n        )\n      }\n\n      // Still visible? Use boundingClientRect as a final check, it's expensive\n      // so we should strive no to call it if it's unnecessary\n      if (visible) {\n        const rect: BeamRect = element.getBoundingClientRect()\n        visible = (rect.width > 0 && rect.height > 0)\n      }\n    }\n    return visible\n  }\n\n  /**\n   * Returns whether an element is either a video or an audio element\n   *\n   * @param element\n   */\n  static isMedia(element: BeamElement): boolean {\n    return  (\n      [\"video\", \"audio\"].includes(element.tagName.toLowerCase()) || \n      Boolean(element.querySelectorAll(\"video, audio\").length)\n    )\n  }\n\n  /**\n   * Check whether an element is an image, or has a background-image url\n   * the background image can be a data:uri. Or has any child that is a img or svg.\n   *\n   * @param element\n   * @param win\n   * @return If the element is considered visible\n   */\n   static isImageOrContainsImageChild(element: BeamElement, win: BeamWindow): boolean {\n    const matcher = (element: BeamElement) => (\n      [\"img\", \"svg\"].includes(element.tagName.toLowerCase())\n      || Boolean(element.querySelectorAll(\"img, svg\").length)\n    )\n    return BeamElementHelper.isImage(element, win, matcher)\n  }\n\n  static imageElementMatcher = (element: BeamElement) => [\"img\", \"svg\"].includes(element.tagName.toLowerCase())\n  /**\n   * Check whether an element is an image, or has a background-image url\n   * the background image can be a data:uri\n   *\n   * @param element\n   * @param win\n   * @return If the element is considered visible\n   */\n   static isImage(element: BeamElement, win: BeamWindow, matcher = BeamElementHelper.imageElementMatcher): boolean {\n     // currentSrc vs src\n     if (matcher(element)) {\n       return true\n     }\n     const style = win.getComputedStyle?.(element)\n     const match = style?.backgroundImage.match(/url\\(([^)]+)/)\n     return !!match\n   }\n \n\n  /**\n   * Returns whether an element is an image container, which means it can be an image\n   * itself or recursively contain only image containers\n   *\n   * @param element\n   * @param win\n   */\n  static isImageContainer(element: BeamElement, win: BeamWindow): boolean {\n    if (BeamElementHelper.isImage(element, win)) {\n      return true\n    }\n    if (element.children.length > 0) {\n      return [...element.children].every(\n          child => BeamElementHelper.isImageContainer(child, win)\n      )\n    }\n    return false\n  }\n\n  /**\n   * Returns the root svg element for the given element if any\n   * @param element\n   */\n  static getSvgRoot(element: BeamElement): BeamElement {\n    if ([\"body\", \"html\"].includes(element.tagName.toLowerCase())) {\n      return\n    }\n    if (element.tagName.toLowerCase() === \"svg\") {\n      return element\n    }\n    if (element.parentElement) {\n      return BeamElementHelper.getSvgRoot(element.parentElement)\n    }\n  }\n\n  /**\n   * Returns the first positioned element out of the element itself and its ancestors\n   *\n   * @param element\n   * @param win\n   */\n  static getPositionedElement(element: BeamElement, win: BeamWindow): BeamElement {\n    // Ignore body\n    if (!element || element === win.document.body) {\n      return\n    }\n    const style = win.getComputedStyle?.(element)\n\n    if (element.parentElement && style?.position === \"static\") {\n      return BeamElementHelper.getPositionedElement(element.parentElement, win)\n    }\n    if (style?.position !== \"static\") {\n      return element\n    }\n  }\n\n  /**\n   * Return the first overflow escaping element. Since css overflow can be escaped by positioning\n   * an element relative to the viewport, either by using `fixed`, or `absolute` in the case\n   * there's no other positioning context\n   *\n   * @param element\n   * @param clippingContainer\n   * @param win\n   */\n  static getOverflowEscapingElement(element: BeamElement, clippingContainer: BeamElement, win: BeamWindow): BeamElement {\n    // Ignore body\n    if (!element || element === win.document.body) {\n      return\n    }\n    const style = win.getComputedStyle?.(element)\n    if (style) {\n      switch (style.position) {\n        case \"absolute\": {\n          // If absolute, we need to make sure it's not within a positioned element already\n          const positionedAncestor = BeamElementHelper.getPositionedElement(element.parentElement, win)\n          if (positionedAncestor && positionedAncestor.contains(clippingContainer)) {\n            return element\n          }\n          return element\n        }\n        case \"fixed\":\n          // Fixed elements always escape overflow clipping\n          return element\n        default:\n          return BeamElementHelper.getOverflowEscapingElement(\n              element.parentElement, clippingContainer, win\n          )\n      }\n    }\n  }\n\n  /**\n   * Recursively look for the first ancestor element with an `overflow`, `clip`, or `clip-path\n   * css property triggering clipping on the element\n   *\n   * @param element\n   * @param win\n   */\n  static getClippingElement(element: BeamElement, win: BeamWindow): BeamElement {\n    // Ignore body\n    if (element === win.document.body) {\n      return\n    }\n    const style = win.getComputedStyle?.(element)\n    if (style) {\n      if (\n          style.getPropertyValue(\"overflow\") === \"visible\"\n          && style.getPropertyValue(\"overflow-x\") === \"visible\"\n          && style.getPropertyValue(\"overflow-y\") === \"visible\"\n          && style.getPropertyValue(\"clip\") === \"auto\"\n          && style.getPropertyValue(\"clip-path\") === \"none\"\n      ) {\n        if (element.parentElement) {\n          return BeamElementHelper.getClippingElement(element.parentElement, win)\n        }\n      } else {\n        return element\n      }\n    } else {\n      if (element.parentElement) {\n        return BeamElementHelper.getClippingElement(element.parentElement, win)\n      }\n    }\n    return\n  }\n\n  /**\n   * Inspect the element itself and its ancestors and return the collection of elements\n   * with clipping active due to the presence of `overflow`, `clip` or `clip-path` css properties\n   *\n   * @param element\n   * @param win\n   */\n  static getClippingElements(element: BeamElement, win: BeamWindow<any>): BeamElement[] {\n    const clippingElement = BeamElementHelper.getClippingElement(element, win)\n    if (!clippingElement) {\n      return []\n    }\n    if (clippingElement.parentElement && clippingElement.parentElement !== win.document.body) {\n      return [\n        clippingElement,\n        ...BeamElementHelper.getClippingElements(clippingElement.parentElement, win)\n      ]\n    }\n    return [clippingElement]\n  }\n\n  /**\n   * Compute intersection of all the clipping areas of the given elements collection\n   * the resulting area might extend infinitely in one of its dimensions\n   *\n   * @param elements\n   * @param win\n   */\n  static getClippingArea(elements: BeamElement[], win: BeamWindow<any>): BeamRect {\n    const areas: BeamRect[] = elements.map(el => {\n      const style = win.getComputedStyle?.(el)\n      if (style) {\n        const overflowX = style.getPropertyValue(\"overflow-x\") !== \"visible\"\n        const overflowY = style.getPropertyValue(\"overflow-y\") !== \"visible\"\n        const bounds = el.getBoundingClientRect()\n        if (overflowX && !overflowY) {\n          return {x: bounds.x, width: bounds.width, y: -Infinity, height: Infinity}\n        }\n        if (overflowY && !overflowX) {\n          return {y: bounds.y, height: bounds.height, x: -Infinity, width: Infinity}\n        }\n        return bounds\n      }\n    })\n\n    return areas.reduce(\n        (clippingArea, area) => (\n            clippingArea\n                ? BeamRectHelper.intersection(clippingArea, area)\n                : area\n        ), null\n    )\n  }\n\n  /**\n   * Returns the clipping containers which the element doesn't contain\n   * @param element\n   * @param win\n   */\n  static getClippingContainers(element: BeamElement, win: BeamWindow): BeamElement[] {\n    return BeamElementHelper\n        .getClippingElements(element, win)\n        .filter(container => {\n          const escapingElement = BeamElementHelper.getOverflowEscapingElement(element, container, win)\n          return !escapingElement || escapingElement.contains(container)\n        })\n  }\n  /**\n   * Checks if target is 120% taller or 110% wider than window frame.\n   *\n   * @static\n   * @param {DOMRect} bounds element bounds to check\n   * @param {BeamWindow} win \n   * @return {*}  {boolean} true if either width or height is large\n   * @memberof PointAndShootHelper\n   */\n   static isLargerThanWindow(bounds: DOMRect, win: BeamWindow): boolean {  \n    const windowHeight = win.innerHeight\n    const yPercent = (100 / windowHeight) * bounds.height\n    const yIsLarge = yPercent > 110\n    // If possible return early to skip the second win.innterWidth call\n    if (yIsLarge) {\n      return yIsLarge\n    }\n    \n    const windowWidth = win.innerWidth\n    const xPercent = (100 / windowWidth) * bounds.width\n    const xIsLarge = xPercent > 110\n    return xIsLarge\n  }\n}\n"]}