{"version":3,"file":"BeamTypes.js","sourceRoot":"","sources":["../../src/BeamTypes.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Types used by Beam API (to exchange messages, typically).\n */\n\nexport class BeamSize {\n  constructor(public width: number, public height: number) {}\n}\n\nexport enum MediaPlayState {\n  ready = \"ready\",\n  playing = \"playing\",\n  paused = \"paused\",\n  ended = \"ended\",\n}\n\nexport interface BeamMediaState {\n  playState: MediaPlayState\n  muted: boolean\n  pipSupported: boolean\n  isInPip: boolean\n}\n\nexport interface BeamRangeGroup {\n  id: string\n  range: BeamRange\n  text?: string\n}\n\nexport interface BeamShootGroup {\n  id: string\n  element: BeamHTMLElement\n  text?: string\n}\n\nexport interface BeamElementBounds {\n  element: BeamHTMLElement | BeamElement\n  rect: BeamRect\n}\n\nexport interface BeamVisualViewport {\n  /**\n   * @type {number}\n   */\n  offsetTop\n\n  /**\n   * @type {number}\n   */\n  pageTop\n\n  /**\n   * @type {number}\n   */\n  offsetLeft\n\n  /**\n   * @type {number}\n   */\n  pageLeft\n\n  /**\n   * @type {number}\n   */\n  width\n\n  /**\n   * @type {number}\n   */\n  height\n\n  addEventListener(name, cb)\n}\n\nexport interface BeamResizeInfo {\n  width: number\n  height: number\n}\n\nexport interface BeamEmbedContentSize {\n  width: number\n  height: number\n}\n\nexport class BeamRect extends BeamSize {\n  constructor(public x: number, public y: number, width: number, height: number) {\n    super(width, height)\n  }\n}\n\nexport class NoteInfo {\n  /**\n   * @type string\n   */\n  id // Should not be nullable once we get it\n\n  /**\n   * @type string\n   */\n  title\n}\n\nexport type MessagePayload = Record<string, unknown>\n\nexport interface BeamMessageHandler {\n  postMessage(message: MessagePayload, targetOrigin?: string, transfer?: Transferable[]): void\n}\n\nexport type MessageHandlers = {\n  [name: string]: BeamMessageHandler\n}\n\nexport interface BeamWebkit<M = MessageHandlers> {\n  /**\n   *\n   */\n  messageHandlers: M\n}\n\nexport interface BeamCrypto {\n  getRandomValues: any\n}\n\nexport interface BeamWindow<M = MessageHandlers> extends BeamEventTarget {\n  onunload: () => void\n  matchMedia(arg0: string)\n  crypto: BeamCrypto\n  frameElement: any\n  frames: BeamWindow[]\n  /**\n   * @type string\n   */\n  origin\n\n  /**\n   * @type BeamDocument\n   */\n  readonly document: BeamDocument\n\n  /**\n   * @type number\n   */\n  scrollY\n\n  /**\n   * @type number\n   */\n  scrollX\n\n  /**\n   * @type number\n   */\n  innerWidth\n\n  /**\n   * @type number\n   */\n  innerHeight\n\n  /**\n   * @type {BeamVisualViewport}\n   */\n  visualViewport\n\n  location: BeamLocation\n\n  webkit: BeamWebkit<M>\n\n  scroll(xCoord: number, yCoord: number): void\n\n  scrollTo(xCoord: number, yCoord: number)\n\n  getComputedStyle(el: BeamElement, pseudo?: string): CSSStyleDeclaration\n\n  open(url?: string, name?: string, specs?: string, replace?: boolean): BeamWindow<M> | null\n}\n\nexport type BeamLocation = Location\n\nexport enum BeamNodeType {\n  element = 1,\n  text = 3,\n  processing_instruction = 7,\n  comment = 8,\n  document = 9,\n  document_type = 10,\n  document_fragment = 11,\n}\n\nexport interface BeamEvent {\n  readonly type: string\n  readonly defaultPrevented: boolean\n}\n\nexport interface BeamEventTarget<E extends BeamEvent = BeamEvent> {\n  addEventListener(type: string, callback: (e: E) => any, options?: any)\n\n  removeEventListener(type: string, callback: (e: E) => any)\n\n  dispatchEvent(e: E)\n}\n\nexport type BeamDOMRect = DOMRect\n\nexport enum BeamWebkitPresentationMode {\n  inline = \"inline\", \n  fullscreen = \"fullscreen\",\n  pip = \"picture-in-picture\"\n}\n\nexport interface BeamNode extends BeamEventTarget {\n  isConnected?: boolean\n  offsetHeight: number\n  offsetWidth: number\n  textContent: string\n  nodeName: string\n  nodeType: BeamNodeType\n  childNodes: BeamNode[]\n  parentNode?: BeamNode\n  parentElement?: BeamElement\n  muted?: boolean\n  paused?: boolean\n  webkitSetPresentationMode(BeamWebkitPresentationMode)\n\n  /**\n   * Mock-specific property\n   * @deprecated Not because it will be removed, but to warn about non-standard.\n   */\n  bounds: BeamRect\n\n  /**\n   * @param el {HTMLElement}\n   */\n  appendChild(el: BeamElement): BeamNode\n\n  /**\n   * @param el {HTMLElement}\n   */\n  removeChild(el: BeamHTMLElement)\n\n  contains(el: BeamNode): boolean\n}\n\nexport interface BeamParentNode extends BeamNode {\n  children: BeamHTMLCollection\n}\n\nexport interface BeamCharacterData extends BeamNode {\n  data: string\n}\n\nexport type BeamText = BeamCharacterData\n\nexport interface BeamElement extends BeamParentNode {\n  cloneNode(arg0: boolean): BeamElement\n  querySelectorAll(query: string): BeamElement[]\n  removeAttribute(pointDatasetKey: any)\n  focus()\n  dataset: any\n  attributes: NamedNodeMap\n  srcset?: string\n  currentSrc?: string\n  src?: string\n  id?: string\n\n  /**\n   * @type string\n   */\n  innerHTML: string\n\n  outerHTML: string\n\n  classList: DOMTokenList\n\n  readonly offsetParent: BeamElement\n\n  readonly parentNode?: BeamNode\n  readonly parentElement?: BeamElement\n\n  /**\n   * Parent padding-relative x coordinate.\n   */\n  offsetLeft: number\n\n  /**\n   * Parent padding-relative y coordinate.\n   */\n  offsetTop: number\n\n  /**\n   * Left border width\n   */\n  clientLeft: number\n\n  /**\n   * Top border width\n   */\n  clientTop: number\n  height: number\n  width: number\n  scrollLeft: number\n  scrollTop: number\n  scrollHeight: number\n  scrollWidth: number\n  tagName: string\n  href: string\n  getClientRects(): DOMRectList\n  setAttribute(qualifiedName: string, value: string): void\n  getAttribute(qualifiedName: string): string | null\n\n  /**\n   * Viewport-relative position.\n   */\n  getBoundingClientRect(): DOMRect\n}\n\nexport interface BeamElementCSSInlineStyle {\n  style: CSSStyleDeclaration\n}\n\nexport interface BeamHTMLElement extends BeamElement, BeamElementCSSInlineStyle {\n  innerText: string\n  nodeValue: any\n  dataset: Record<string, string>\n}\n\nexport interface BeamHTMLInputElement extends BeamHTMLElement {\n  type: string\n  value: string\n}\n\nexport interface BeamHTMLTextAreaElement extends BeamHTMLElement {\n  value: string\n}\n\nexport interface BeamHTMLIFrameElement extends BeamHTMLElement {\n  src: string\n}\n\nexport interface BeamBody extends BeamHTMLElement {\n  /**\n   * @type String\n   */\n  baseURI\n\n  /**\n   * @type number\n   */\n  scrollWidth\n\n  /**\n   * @type number\n   */\n  offsetWidth\n\n  /**\n   * @type number\n   */\n  clientWidth\n\n  /**\n   * @type number\n   */\n  scrollHeight\n\n  /**\n   * @type number\n   */\n  offsetHeight\n\n  /**\n   * @type number\n   */\n  clientHeight\n}\n\nexport interface BeamRange {\n  commonAncestorContainer: BeamNode\n  cloneContents(): DocumentFragment\n  cloneRange(): BeamRange\n  collapse(toStart?: boolean): void\n  compareBoundaryPoints(how: number, sourceRange: BeamRange): number\n  comparePoint(node: BeamNode, offset: number): number\n  createContextualFragment(fragment: string): DocumentFragment\n  deleteContents(): void\n  detach(): void\n  extractContents(): DocumentFragment\n  getClientRects(): DOMRectList\n  insertNode(node: BeamNode): void\n  intersectsNode(node: BeamNode): boolean\n  isPointInRange(node: BeamNode, offset: number): boolean\n  selectNodeContents(node: BeamNode): void\n  setEnd(node: BeamNode, offset: number): void\n  setEndAfter(node: BeamNode): void\n  setEndBefore(node: BeamNode): void\n  setStart(node: BeamNode, offset: number): void\n  setStartAfter(node: BeamNode): void\n  setStartBefore(node: BeamNode): void\n  surroundContents(newParent: BeamNode): void\n  toString(): string\n  END_TO_END: number\n  END_TO_START: number\n  START_TO_END: number\n  START_TO_START: number\n  collapsed: boolean\n  endContainer: BeamNode\n  endOffset: number\n  startContainer: BeamNode\n  startOffset: number\n  selectNode(node: BeamNode): void\n  getBoundingClientRect(): DOMRect\n}\n\nexport declare const BeamRange: {\n  prototype: BeamRange\n  new (): BeamRange\n  readonly END_TO_END: number\n  readonly END_TO_START: number\n  readonly START_TO_END: number\n  readonly START_TO_START: number\n  toString(): string\n}\n\nexport interface BeamDocument extends BeamNode {\n  createDocumentFragment(): any\n  elementFromPoint(x: any, y: any)\n  createTreeWalker(root: BeamNode, whatToShow?: number, filter?: NodeFilter | null, expandEntityReferences?: boolean): TreeWalker;\n  createTextNode(data: string): Text;\n  /**\n   * @type {HTMLHtmlElement}\n   */\n  documentElement\n\n  activeElement: BeamHTMLElement\n\n  /**\n   * @type BeamBody\n   */\n  body: BeamBody\n\n  /**\n   * @param tag {string}\n   */\n  createElement(tag)\n\n  /**\n   * @return {BeamSelection}\n   */\n  getSelection()\n\n  /**\n   * @param selector {string}\n   * @return {HTMLElement[]}\n   */\n  querySelectorAll(selector: string): BeamNode[]\n\n  /**\n   * @param selector {string}\n   * @return {HTMLElement}\n   */\n  querySelector(selector: string): BeamNode\n\n  createRange(): BeamRange\n}\n\n/**\n * {x, y} of mouse location\n *\n * @export\n * @interface BeamMouseLocation\n */\nexport interface BeamMouseLocation {\n  x: number\n  y: number\n}\n\nexport interface BeamSelection {\n  anchorNode: BeamNode\n  anchorOffset: number\n  focusNode: BeamNode\n  focusOffset: number\n  isCollapsed: boolean\n  rangeCount: number\n  type: string\n  addRange(range: BeamRange): void\n  collapse(node: BeamNode, offset?: number): void\n  collapseToEnd(): void\n  collapseToStart(): void\n  containsNode(node: BeamNode, allowPartialContainment?: boolean): boolean\n  deleteFromDocument(): void\n  empty(): void\n  extend(node: BeamNode, offset?: number): void\n  getRangeAt(index: number): BeamRange\n  removeAllRanges(): void\n  removeRange(range: BeamRange): void\n  selectAllChildren(node: BeamNode): void\n  setBaseAndExtent(anchorNode: BeamNode, anchorOffset: number, focusNode: BeamNode, focusOffset: number): void\n  setPosition(node: BeamNode, offset?: number): void\n  toString(): string\n}\n\nexport interface BeamMutationRecord {\n  addedNodes: BeamNode[]\n  attributeName: string\n  attributeNamespace: string\n  nextSibling: BeamNode\n  oldValue: string\n  previousSibling: BeamNode\n  removedNodes: BeamNode[]\n  target: BeamNode\n  type: MutationRecordType\n}\n\nexport class BeamMutationObserver {\n  constructor(public fn) {\n    new fn()\n  }\n  disconnect(): void {\n    throw new Error(\"Method not implemented.\")\n  }\n  observe(_target: BeamNode, _options?: MutationObserverInit): void {\n    throw new Error(\"Method not implemented.\")\n  }\n  takeRecords(): BeamMutationRecord[] {\n    throw new Error(\"Method not implemented.\")\n  }\n}\n\nexport class BeamResizeObserver implements ResizeObserver {\n  constructor() {}\n  disconnect(): void {\n    throw new Error(\"Method not implemented.\")\n  }\n  observe(target: Element, options?: ResizeObserverOptions): void {\n    throw new Error(\"Method not implemented.\")\n  }\n  unobserve(target: Element): void {\n    throw new Error(\"Method not implemented.\")\n  }\n}\n\nexport interface BeamCoordinates {\n  x: number \n  y: number\n}\n\nexport class FrameInfo {\n  /**\n   */\n  href: string\n\n  /**\n   */\n  bounds: BeamRect\n\n  scrollSize?: BeamFrameScrollSizing\n}\n\nexport interface BeamFrameScrollSizing {\n  width: number\n  height: number\n}\n\nexport enum BeamLogLevel {\n  log = \"log\",\n  warning = \"warning\",\n  error = \"error\",\n  debug = \"debug\"\n}\n\n\nexport enum BeamLogCategory {\n  general = \"general\",\n  pointAndShoot = \"pointAndShoot\",\n  embedNode = \"embedNode\",\n  webpositions = \"webpositions\",\n  navigation = \"navigation\",\n  native = \"native\",\n  passwordManager = \"passwordManager\",\n  webAutofillInternal = \"webAutofillInternal\"\n}\n\nexport class BeamHTMLCollection<E extends BeamElement = BeamElement> /*implements HTMLCollection*/ {\n  constructor(private values: E[]) {\n  }\n\n  [index: number]: E\n\n  get length(): number {\n    return this.values.length\n  }\n\n  [Symbol.iterator](): IterableIterator<E> {\n    return this.values.values()\n  }\n\n  item(index: number): E | null {\n    return this.values[index]\n  }\n\n  namedItem(name: string): E | null {\n    return this.item(parseInt(name, 10))\n  }\n}\n"]}